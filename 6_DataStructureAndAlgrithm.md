# 6 数据结构
 ## 6.1跳表
 1. 跳表和红黑树很像，都可以支持快速的插入、删除、查找操作。
 2. 如何避免复杂度退化，以及查找、插入、删除操作性能下降？
 A:跳表是通过随机函数来维护平衡性，通过一个随机函数，来决定这个结点插入到哪几级索引中。比如随机函数生成了值K，那我们将这个节点添加到第一级到第K级这K级索引中。
 3. Redis为什么要用跳表来实现有序集合，而不是红黑树？
 A:Redis的有序集合是通过跳表来实现的，Redis中的有序集合支持的核心操作主要有下面几个：插入、删除、查找、按照区间查找数据和迭代输出有序序列。其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。
 
 ---
 
 ## 6.2 哈希表
 1. 散列冲突
 > **开放寻址法**
 > 开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。重新探测的方法：线性探测（在冲突后一个位置）、二次探测（在冲突后两个位置）和双重散列（换个hash函数）。**缺点**：删除数据很麻烦，需要特殊标记已经删除掉的数据。不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。**优势**：开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效的抵用CPU缓存加快查询速度。而且这种方法实现的散列表，序列化起来比较简单。链表法因为有指针，所以序列化起来就没那么容易。**总结**：当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是Java中的ThreadLoaclMap使用开放寻址法解决散列冲突的原因。
 > **链表法**
 > 链表法是一种更加常用的散列冲突解决方法，相比开放寻址法，它要简单很多。所有hash值相同的元素都放到相同槽位对应的链表中。**优势**：对内存的利用率比开放寻址法要高，对大装载因子的容忍度更高
 2. Word文档中单词拼写检查功能是如何实现的？
 A：常用的单词有20万个，平均一个单词占用10个字节的内存空间，那20万英文单词大约占2MB的存储空间，就算放大10倍也就是20MB，所以我们可以用散列表来存储整个英文单词词典。
3. 如何避免低效地扩容？
> 为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，我们将新数据插入散列表，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就变的很快了。
4. 装载因子=填入表中的元素个数/散列表的长度
---
## 6.3 深度和广度搜索算法
1. 深度优先搜索算法的时间复杂度是O(E)，E表示边的个数。空间复杂度为O（V），V为顶点的个数。
2. 广度优先搜索算法的的时间复杂度是O(E+V)，空间复杂度为O(V)。
