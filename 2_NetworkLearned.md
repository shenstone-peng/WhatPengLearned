# 2计算机网络
## 2.1网络概述
1. 五层网络协议
  ```c++


+----------------------+
|                      |
|      应用层           |  特殊进程之间特定的通信协议。（FTP/IMAP）
+----------------------+
|                      |
|      传输层           |  为计算机中不同进程之间的通信存在的协议。（TCP/UDP）
+----------------------+
|                      |
|      网络层           |  为识别不同网口（比如WIFI和以太网）的通信存在的协议。（IP）
+----------------------+
|                      |
|      连接层           |  信息以帧为单位传输。连接层协议的功能就是识别0/1序列中包含的帧。（以太网/WIFI）
+----------------------+
|                      |
|      物理层           |  通过将信号转换为1和0在媒介进行传输
+----------------------+

```

---
## 2.2 连接层
1. 以太网和WiFi是连接层的两种协议。信息以帧为单位传输。帧结构包括头部（序言、起始信号、目的地、发出地和类型）、数据和尾部（校验序列）

```c++
    content: Preamble |SFD|Destination|Source|Type|payload（data）|fcs|extension  
    bit :    ---7---- |-8-|6----------|6-----|16----------------  |   |
```
2. mac地址是物理设备自带的序号，只能在同一个以太网中被识别（正如邮差只熟悉自己的社区一样）

---
## 2.3网络层
1. IP包格式
```
    |-------------------------------------------------------- --- ------|  
    |-version-|-ihl--|-type of service-|--------total-length------------|  
    |------identificaiton--------------|-flags-|-fragment offset------- |  
    |-time-to-live---| protocol        | header checksum----------------|  
    |--------------------source address--------------------------- -----|  
    |-----------------------destination address------------------- -----|  
    |---------options--------------------- --|---- -----padding---------|  
    |-----------------------------data--------------------------------- |
```
2. IP协议像是接力棒，通过路由表判断将信息送到哪个网卡。
3. ARP协议：找到IP地址和MAC的对应关系
4. RIP协议：智能拓展routing table
---
## 2.4传输层协议
###  2.4.1 TCP [学习源地址](https://coolshell.cn/articles/11564.html) [学习源地址2](https://www.cnblogs.com/linguoguo/p/10519635.html)
1. tcp包
> sequence number是包的序号，用来解决网络包乱序(reordering)问题。 
> Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。
>  Window又叫Advertised-Window，也就是著名的滑动窗口(Sliding Window)，用于解决流控的。
>   TCP Flag也就是包的类型，主要是用于操控TCP的状态机的。
2. TCP的状态机
> 网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。
```c++
                          +--------------+
                          |              |
       +------------------+   CLOSED     +--------------+
       |                  +--------------+              |
       |                                                |
       |                                                |
       |Passive Open                                    |
       |Set Up TCB                                      |
       |                                                |
       |                                                |
       v                                     Active Open Set Up TCB
+------+-------+                                  Send SYN
|              |        <-------------------------------| connect()
|   LISTEN     |listen()        SYN  seq=x              |
+-----+--------+                                        |
      |                                                 |
      |                                                 |
      | Receive SYN    +---------------------------->   |
      | Send SYN+ACK       SYN seq=y ACK=x+1            |
      |                                                 |
      |                                                 v
+-----v---------+       Simultaneous Open         +-----+-------+
|               |     Receive SYN Send ACK        |             |
| SYN-RECEIVED  +<--------------------------------+ SYN-SENT    |
+-------+-------+                                 +-----+-------+
        |             <------------------------+        |
        |                  ACK=y+1                      |
        |                                               |
        |Receive ACK                                    |Receive SYN+ACK
        |                                               |Send ACK
        |                                               |
        |              +-------------------+            |
        |              |                   |            |
        +------------->+   ESTABLISHED     +<-----------+
                       +-------------------+
                         |      |
      FIN seq=x+2 ACK=y+1|      |         Recei^e FIN Send ACK=x+3
           +-------------+      +----------------+
           |   close()                           |
    +------v-------+                      +------v-------+
    |  FIN-WAIT-1  |                      |  CLOSE-WAIT  |
    +---+------+---+                      +--------------+
        |      |                                  |
        |      |                                  |
        |      |                                  |
        |      |  Recieve Fin Send ACK            |
        |      +------------+                     |Wait for Application Close
        |                   |                     |  Send FIN
Receive ACK for FIN         |                     |
        ^                   v                     v
   +----+--------+      +---+---------+   +-------+----+
   |  FIN-WAIT-2 |      |  CLOSING    |   |  LAST-ACK  |
   +-------------+      +---+---------+   +---------+--+
 Receive FIN                |                       |
    Send ACK                |Receive ACK for FIN    |
        |     +-------------v+                      v
        +-----> TIME-WAIT    |                    +-+-------------+
              |              +------------------->+               |
              +--------------+                    |    CLOSED     |
                                                  +---------------+


```
3. 当server端socket在SYN-RECEIVED状态时，client端断链了，会重试发SYN-ACK，时间间隔为1s,2s,4s,8s,16s，总共31s，第5次发出后等待32s，如果没有回复就会断开这个链接。
> **关于SYN FLOOD攻击**：给服务器发一个SYN就下线，于是服务器需要默认等待63s才会断开连接，这样就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。
> **解决方案**：Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了之后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个SYN Cookie发回来，然后服务端可以通过cookie建连接（即使不在SYN队列中）；tcp_synack_retries参数减少重试次数；tcp_max_syn_backlog参数增大SYN连接数；tcp_abort_on_overflow参数实在处理不过直接拒绝连接
4. **关于ISN的初始化**：ISN不能hard code，会在网络不稳定时，接收端无法确定包的顺序和是否有用。RFC793里规定，ISN会和一个假的时钟绑在一起，这个时钟会在每4微妙对ISN做加1的操作，直到超过2^32，又从0开始。这样一个ISN的周期大约是4.55小时，因为我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime，所以只要MSL的值小于4.55小时，那么我们就不会重用到ISN。
5. **关于MSL和TIME_WAIT**：最后发出ACK，肯定要想一下对面有没有收到啊，因为TCP Segment最迟会花费1个MSL送到对面，如果对面1个MSL都没收到你的ACK，对面就会再次发一个FIN给你，就又得等1个MSL。一来一回，两个MSL，所以在发出ACK后，会进入TIME_WAIT状态，等待2个MSL时间，socket状态才会CLOSED。
6. **超时重传机制** ：在未收到该收到的包后，就不发ACK，知道发送端发觉TIME OUT后，重传缺失的包。**问题**：等待timeout 时间太久，也不知道要重传哪些包，可能会浪费带宽
7. **快速重传机制**：Fast Retransmit，接收端在未收到该收到的包后，会重复发上一个接收的包的ACK，连发三次后，发送端知道这个包没收到，会重发。**问题**解决了不需要等待timeout，但还是没解决不知道要重传哪些包的问题。
8. **SACK方法**：这种方式在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报接收到的数据碎版。
9. **TCP的RTT算法**：RTT是一个数据包从发出去到回来的时间。RTO（Retransmission Time Out）超时时间
> **经典算法** ：每次采样RTT值，便与SRTT加权求出新的SRTT。缺陷：很难处理重传时候的RTT值。
> **Karn/Partrigdge**算法：忽略重传，不把重传的RTT做采样，如果遇到重传直接double rto值。缺陷：这种死规矩对于一个需要估计比较准确的RTT不靠谱。
> **Jacobson/Karels**:消除当RTT有大波动的情况
10. **TCP滑动窗口**：TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。
11. **TCP的拥塞处理**：如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断的放大。
> **慢启动**：window一开始很小，然后每成功传输一次，窗口大小加1，每过一个RTT时间，窗口大小double。说是慢启动，但当网络情况好的时候，速度很快就上来了，因为网络情况好，收到ACK的时间快，收到ACK的时间短，所以RTT时间就短，window大小就一直double。
> **拥塞避免算法**：当window到一个很大的值后（ssthresh=65535字节），会慢慢增长，不再会直接double。
> **拥塞状态算法**：当重传发生时，会重置window窗口大小为1，然后重新开始慢启动，不同的是，ssthresh会减半。
> **快速恢复算法**：一般与快速重传算法一起使用，当收到3个Duplicated ACK后，说明网络也没那么糟糕，调整窗口为（sshthresh+3*MSS）。
> **FACK算法**：用来做SACK重传过程中的拥塞流控。
12. **SYN队列**：SYN队列存储了收到SYN包的连接，它的职责是回复SYN+ACK包，并且在没有收到ACK包时重传，直到超时。发送完SYN+ACK后，SYN队列等待从客户端发出的ACK包。当收到ACK包时，首先找到对应的SYN队列，再在对应的SYN队列中检查相关的数据看是否匹配。内核将该连接相关的数据从SYN队列中移除，创建一个完整的连接，并将这个连接加入到Accept队列。
13. **Accept队列**：Accept队列中存放的是已建立好的连接，也即等待被上层应用程序取走的连接。当进程调用accpet()，这个socket从队列中取出，传递给上层应用程序。
14. **队列大小设置多少合适**：看情况，对于大多数的TCP服务来说，这并不重要。尽管如此也存在一些合理的原因，需要增大队列的大小
> 当建立连接的请求速度缺失很大时，即使是对于一个高性能的服务来说，SYN队列也可能需要设置的大一些。
> SYN队列的大小，换言之就是等待ACK包的连接数。也即与客户端的平均往返时间越大，堆积在SYN队列中的连接就越多。对于那些大部分客户端都距离服务器很远的场景。比如说往返时间几百毫秒以上，可以将队列大小设置的大一些。
> TCP_DEFER_ACCPET选项如果打开了，会导致socket在SYN-RECV状态下维持更长的时间，也即增大了处于SYN队列中的时间。
> 队列设置太大的缺点：syn队列中的每一个槽位都需要占用一些内存。当遇到SYN_Flood攻击时，我们没必要为这些发起攻击的包浪费资源。SYN队列中的inet_request_sock结构体，在4.14内核下，每个将占用256字节的内存。
15. **查看socket状态命令**：
```bash
ss -n state syn-recv sport=:80|wc -l    
#查看80端口处于syn-recv状态的socket数量
```
16.  **循环抓包法**
命令：
```bash
nohup tcpdump -i eth3 host 192.168.201.132 and port 63701 -s0 -C100 -W100 -w /root/ts_dump.pcap -Z root > /dev/null &
```
> 命令说明：  
> -i eth3 其中eth3----替换为IP所在的网口名称
> host 192.168.201.132 其中IP替换为频道收流的IP地址
> port 63701 其中63701替换为频道收流的端口
> -C100 文件大小100MB
> -W100 文件滚动个数100个
> -w /root/ts_dump.pcap 文件存放路径
> 预估可以抓包保存的时间：100MB（约4分钟），100个文件约（400分钟，大概在6-7小时），可以根据系统盘剩余空间适当调整下文件个数

中断抓包命令：
```bash
pkill -9 tcpdump
```
---
